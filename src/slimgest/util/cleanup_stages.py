import re
from pathlib import Path
from typing import List

import typer
from rich.console import Console
from rich.table import Table
from rich.prompt import Confirm

app = typer.Typer(help="Clean up stage output files from a directory")

console = Console()

# Define stage output file patterns
STAGE_PATTERNS = {
    2: [".page_elements_v3.json", ".page_element_detections.png"],
    3: [".graphic_elements_v1.json"],
    4: [".table_structure_v1.json"],
    5: [".nemotron_ocr_v1.json"],
    6: [".embeddings.pt", ".embedder-input.txt"],
    7: [],  # VDB upload doesn't create local files
    8: [],  # Recall analysis creates separate output directories
}


def get_stage_number(stage_str: str) -> int:
    """
    Extract stage number from a stage string like 'stage5', '5', or 'Stage 5'.
    
    Args:
        stage_str: String representing the stage
        
    Returns:
        Integer stage number
        
    Raises:
        ValueError: If the stage string cannot be parsed
    """
    # Try to match patterns like "stage5", "Stage5", "STAGE5"
    match = re.match(r'stage\s*(\d+)', stage_str, re.IGNORECASE)
    if match:
        return int(match.group(1))
    
    # Try to parse as a plain integer
    try:
        return int(stage_str)
    except ValueError:
        raise ValueError(
            f"Invalid stage format: '{stage_str}'. "
            "Expected format: 'stage5', '5', or 'Stage 5'"
        )


def find_stage_files(input_dir: Path, stage_num: int) -> List[Path]:
    """
    Find all files in the input directory that match the given stage's output patterns.
    
    Args:
        input_dir: Directory to search
        stage_num: Stage number
        
    Returns:
        List of file paths matching the stage's output patterns
    """
    if stage_num not in STAGE_PATTERNS:
        return []
    
    patterns = STAGE_PATTERNS[stage_num]
    if not patterns:
        return []
    
    matching_files = []
    for pattern in patterns:
        # Find all files ending with the pattern
        for file_path in input_dir.rglob(f"*{pattern}"):
            if file_path.is_file():
                matching_files.append(file_path)
    
    return sorted(matching_files)


def collect_files_to_delete(input_dir: Path, start_stage: int) -> dict[int, List[Path]]:
    """
    Collect all files to delete for the given stage and all subsequent stages.
    
    Args:
        input_dir: Directory to search
        start_stage: Starting stage number (inclusive)
        
    Returns:
        Dictionary mapping stage number to list of files to delete
    """
    files_by_stage = {}
    
    # Get all stage numbers >= start_stage
    all_stages = sorted(STAGE_PATTERNS.keys())
    stages_to_clean = [s for s in all_stages if s >= start_stage]
    
    for stage_num in stages_to_clean:
        files = find_stage_files(input_dir, stage_num)
        if files:
            files_by_stage[stage_num] = files
    
    return files_by_stage


def format_size(size_bytes: int) -> str:
    """Format file size in human-readable format."""
    for unit in ['B', 'KB', 'MB', 'GB', 'TB']:
        if size_bytes < 1024.0:
            return f"{size_bytes:.2f} {unit}"
        size_bytes /= 1024.0
    return f"{size_bytes:.2f} PB"


@app.command()
def run(
    input_dir: Path = typer.Argument(
        ..., 
        exists=True, 
        file_okay=False,
        help="Directory containing stage output files"
    ),
    stage: str = typer.Argument(
        ...,
        help="Stage number to start deletion from (e.g., 'stage5' or '5'). "
             "All files from this stage onwards will be deleted."
    ),
    dry_run: bool = typer.Option(
        False,
        "--dry-run",
        help="Show what would be deleted without actually deleting"
    ),
    force: bool = typer.Option(
        False,
        "--force",
        "-f",
        help="Skip confirmation prompt"
    ),
):
    """
    Delete stage output files from a directory.
    
    This command finds and deletes all output files generated by the specified stage
    and all subsequent stages. For example, if you specify stage5, it will delete:
    
    \b
    - Stage 5: .nemotron_ocr_v1.json files
    - Stage 6: .embeddings.pt and .embedder-input.txt files
    - Stage 7+: (no local files)
    
    \b
    Examples:
        # Delete stage5 and later (with confirmation)
        slimgest util cleanup-stages ./outputs/simple stage5
        
        # Delete stage6 and later without confirmation
        slimgest util cleanup-stages ./outputs/simple 6 --force
        
        # Dry run to see what would be deleted
        slimgest util cleanup-stages ./outputs/simple stage5 --dry-run
    """
    
    # Parse stage number
    try:
        stage_num = get_stage_number(stage)
    except ValueError as e:
        console.print(f"[bold red]Error:[/bold red] {e}")
        raise typer.Exit(1)
    
    # Validate stage number
    if stage_num not in STAGE_PATTERNS:
        console.print(
            f"[bold red]Error:[/bold red] Stage {stage_num} is not a valid stage number."
        )
        console.print(f"[yellow]Valid stages:[/yellow] {', '.join(map(str, sorted(STAGE_PATTERNS.keys())))}")
        raise typer.Exit(1)
    
    console.print(f"\n[bold cyan]Scanning for stage output files...[/bold cyan]")
    console.print(f"[yellow]Input directory:[/yellow] {input_dir}")
    console.print(f"[yellow]Starting from:[/yellow] Stage {stage_num}\n")
    
    # Collect files to delete
    files_by_stage = collect_files_to_delete(input_dir, stage_num)
    
    if not files_by_stage:
        console.print("[bold green]No files found to delete.[/bold green]")
        return
    
    # Create summary table
    table = Table(title=f"Files to {'Delete' if not dry_run else 'Be Deleted'}")
    table.add_column("Stage", style="cyan", justify="right")
    table.add_column("File Type", style="yellow")
    table.add_column("Count", style="green", justify="right")
    table.add_column("Total Size", style="magenta", justify="right")
    
    total_files = 0
    total_size = 0
    
    for stage_num in sorted(files_by_stage.keys()):
        files = files_by_stage[stage_num]
        stage_size = sum(f.stat().st_size for f in files)
        total_files += len(files)
        total_size += stage_size
        
        # Get file type description
        patterns = STAGE_PATTERNS[stage_num]
        file_types = ", ".join(patterns) if patterns else "N/A"
        
        table.add_row(
            f"Stage {stage_num}",
            file_types,
            str(len(files)),
            format_size(stage_size)
        )
    
    console.print(table)
    console.print(f"\n[bold]Total:[/bold] {total_files} files, {format_size(total_size)}")
    
    if dry_run:
        console.print("\n[bold yellow]DRY RUN MODE[/bold yellow] - No files were deleted.")
        console.print("Run without --dry-run to actually delete files.")
        return
    
    # Confirmation prompt
    if not force:
        console.print()
        confirmed = Confirm.ask(
            f"[bold red]Are you sure you want to delete {total_files} files?[/bold red]",
            default=False
        )
        if not confirmed:
            console.print("[yellow]Deletion cancelled.[/yellow]")
            raise typer.Exit(0)
    
    # Delete files
    console.print("\n[bold cyan]Deleting files...[/bold cyan]")
    deleted_count = 0
    failed_count = 0
    
    for stage_num in sorted(files_by_stage.keys()):
        files = files_by_stage[stage_num]
        for file_path in files:
            try:
                file_path.unlink()
                deleted_count += 1
            except Exception as e:
                console.print(f"[red]Failed to delete {file_path}: {e}[/red]")
                failed_count += 1
    
    # Summary
    console.print()
    if failed_count == 0:
        console.print(f"[bold green]✓ Successfully deleted {deleted_count} files[/bold green]")
    else:
        console.print(
            f"[bold yellow]⚠ Deleted {deleted_count} files, "
            f"failed to delete {failed_count} files[/bold yellow]"
        )
